#' Function to create a \code{SnpMatrix} or a file compatible with \code{PLINK}
#' 
#' This function uses the files created with \code{Ax2APT} (metrix, summary 
#' and genotype) to create a list containing a map file and a SnpMatrix with 
#' the genotype of each probe in the array. It can also be used to create 
#' a \code{.tped} file, compatible with \code{PLINK} (is in charge of the user 
#' to create the partner \code{.tfam} file).
#' 
#' @param calls.file Location where the 'intermediate' files (metrix, summary 
#' and genotype) generated by \code{Ax2APT}.
#' @param annotation.file NetAffx Annotation database file in CSV format.
#' @param output.type By default \code{"snpmatrix"}. Can be set to 
#' \code{"plink"} to generate a \code{.tped} file.
#' @param output.name If \code{output.type} is set to \code{"plink"}, it must 
#' contain the name of the output \code{.tped} file (with no extension).
#' @param verbose By default FALSE. If TRUE the function will shows messages 
#' indicating the process.
#' @examples 
#' \dontrun{
#' # To create a SnpMatrix Container (a list with a map and a SnpMatrix)
#'  smc <- Ax2SnpMatrix(
#'  calls.file=paste0(output.path, .Platform$file.sep, "AxiomGT1.calls.txt"),
#'  annotation.file=paste0(path.lib, .Platform$file.sep, "Axiom_GW_Hu_SNP.na34.annot.csv"),
#'  output.type="snpmatrix"
#'  )
#' }
#' \dontrun{
#' # To create the .tped file compatible with PLINK
#'  Ax2SnpMatrix(
#'  calls.file=paste0(output.path, .Platform$file.sep, "AxiomGT1.calls.txt"),
#'  annotation.file=paste0(path.lib, .Platform$file.sep, "Axiom_GW_Hu_SNP.na34.annot.csv"),
#'  output.type="plink",
#'  output.name="ax"
#'  )
#' }
#' @export Ax2SnpMatrix
Ax2SnpMatrix <- function( calls.file, annotation.file, 
    output.type = "snpmatrix", output.name = NA, verbose=FALSE ) {

    # SETUP
    OptionsAffy.Init("Ax2SnpMatrix", verbose)
    OptionsAffy.Cores(1)
    # /SETUP

    # SYSTEM
    CheckSystem(bits=FALSE)
    # /SYSTEM

    output.type <- value( output.type, c( "snpmatrix", "plink" ) )

    # Checking input arguments
    if( output.type == "" ) {
        screen_gw_snp( TRUE, "Argument 'output.type' must be 'snpmatrix' or 'plink'." )
        stop( "HALT." )
    }
    if( output.type == "plink" & is.na( output.name ) ) {
        screen_gw_snp( TRUE, "If 'output.type' is 'plink', 'output.name' must be filled." )
        stop( "HALT." )   
    }
    # /Checking input arguments

    ScreenAffy( "Loading calls file." );
    calls <- tryCatch( { read.table( calls.file, row.names=1, comment.char="#", header=TRUE, as.is=TRUE ); },
        warnning=function( w ) { screen_ax_snp( TRUE, "Invalid file provided in \"callsfile\"\n.", w ); stop( "HALT." ); },
        error=function( e ) { screen_ax_snp( TRUE, "Invalid file provided in \"callsfile\".\n", e ); stop( "HALT." ); } );

    ScreenAffy( "Loading annotation file." );
    annot <- tryCatch( { read.csv( annotation.file, row.names=1, comment.char="#", header=TRUE ); },
        warnning=function( w ) { screen_ax_snp( TRUE, "Invalid file provided in \"annotation\".\n", w ); stop( "HALT." ); },
        error=function( e ) { screen_ax_snp( TRUE, "Invalid file provided in \"annotation\".\n", e ); stop( "HALT." ); } );

    

    if( output.type == "snpmatrix" ) {
        
        ScreenAffy( "Coercing calls to SnpMatrix." );
        calls.ind <- new( "SnpMatrix", t( as( calls, "matrix" ) ) );
        
        ScreenAffy( "Creating container." );
        object <- list();
        object$map <- data.frame( annot$Chromosome, annot$dbSNP.RS.ID, as.numeric( annot$Physical.Position ), annot$Allele.A, annot$Allele.B )
        colnames( object$map ) <- c( "chromosome", "dbSNP", "position", "allele.1", "allele.2" );
        rownames( object$map ) <- rownames( annot );
        object$genotype <- calls.ind;
        object$map <- object$map[ colnames( object$genotype ), ]
        
        return( object );
    }
    else {
        
        allA <- as.character( annot$Allele.A );
        allComplA <- c( "A","C","G","T" )[ match( allA, c( "T", "G", "C", "A" ) ) ];
        forwA <- ifelse( annot$Strand=="+", allA, allComplA );
        
        allB <- as.character( annot$Allele.B );
        allComplB <- c( "A","C","G","T" )[ match( allB, c( "T", "G", "C", "A" ) ) ]
        forwB <- ifelse( annot$Strand=="+", allB, allComplB )
        
        
        
        alleleA <- alleleB <- matrix( "", nrow=nrow( calls ), ncol=ncol( calls ), dimnames=dimnames( calls ) );
        for( ii in 1:ncol( calls ) ) {
            alleleA[ , ii ] <- ifelse( calls[ , ii ] < 3, forwA, forwB );
            alleleB[ , ii ] <- ifelse( calls[ , ii ] < 2, forwA, forwB );
        }
        
        
        
        p1 <- seq( 1, ncol( calls )*2, 2 );
        p2 <- seq( 2, ncol( calls )*2, 2 );
        
        tped <- matrix( "", ncol=ncol( calls ) * 2, nrow=nrow( calls ) );
        for( ii in 1:ncol( calls ) ) {
            tped[ , p1[ ii ] ] <- alleleA[ , ii ];
            tped[ , p2[ ii ] ] <- alleleB[ , ii ];
        }
        
        rownames( tped ) <- rownames( calls );
        
        
        
        ScreenAffy( "Selecting SNP data from annotation file." );
        annot <- annot[ rownames( calls ), ];
        annot <- data.frame( annot$Chromosome, annot$dbSNP.RS.ID, as.numeric( annot$ChrX.pseudo.autosomal.region.1 ),  as.numeric( annot$Physical.Position ) );
        
        
        ScreenAffy( "Flatting SNP data with TPED content." );
        tped <- cbind( annot, tped );
        
        
        ScreenAffy( paste0( "Writing TPED file to disk '", output.name, ".tped'." ) );
        write.table( tped, file=paste0( output.name, ".tped" ), quote=FALSE, row.names=FALSE, col.names=FALSE );
    }

    return( NA );
}